// Code generated by goyacc -o cc/crd.go -v cc/crd.output cc/crd.y. DO NOT EDIT.

//line cc/crd.y:2
package cc

import __yyfmt__ "fmt"

//line cc/crd.y:2

import (
	"github.com/berquerant/crd/ast"
	"github.com/berquerant/crd/note"
	"math/big"
)

//line cc/crd.y:11
type yySymType struct {
	yys               int
	score             *ast.Score
	nodeList          []ast.Node
	node              ast.Node
	token             Token
	chordNote         *ast.ChordNote
	chordOption       *ast.ChordOption
	chordBase         *ast.ChordBase
	value             note.Value
	name              note.Name
	augmented         bool
	diminished        bool
	minor             bool
	major             bool
	seventh           bool
	sixth             bool
	suspended         bool
	forth             bool
	accidental        note.Accidental
	accidentaled      int
	keyMinor          bool
	key               note.Key
	transpositionDiff note.Semitone
}

const REST = 57346
const MINOR = 57347
const MAJOR = 57348
const SEVENTH = 57349
const DIMINISHED = 57350
const AUGMENTED = 57351
const SIXTH = 57352
const SUSPENDED = 57353
const FORTH = 57354
const MINUS = 57355
const PLUS = 57356
const SHARP = 57357
const FLAT = 57358
const SLASH = 57359
const INT = 57360
const LBRA = 57361
const RBRA = 57362
const C = 57363
const D = 57364
const E = 57365
const F = 57366
const G = 57367
const A = 57368
const B = 57369
const TEMPO = 57370
const METER = 57371
const KEY = 57372
const INSTRUMENT = 57373
const STRING = 57374
const TRANSPOSITION = 57375

var yyToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"REST",
	"MINOR",
	"MAJOR",
	"SEVENTH",
	"DIMINISHED",
	"AUGMENTED",
	"SIXTH",
	"SUSPENDED",
	"FORTH",
	"MINUS",
	"PLUS",
	"SHARP",
	"FLAT",
	"SLASH",
	"INT",
	"LBRA",
	"RBRA",
	"C",
	"D",
	"E",
	"F",
	"G",
	"A",
	"B",
	"TEMPO",
	"METER",
	"KEY",
	"INSTRUMENT",
	"STRING",
	"TRANSPOSITION",
}

var yyStatenames = [...]string{}

const yyEofCode = 1
const yyErrCode = 2
const yyInitialStackSize = 16

//line cc/crd.y:287

//line yacctab:1
var yyExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const yyPrivate = 57344

const yyLast = 100

var yyAct = [...]int{
	37, 11, 18, 48, 27, 19, 20, 21, 22, 23,
	24, 25, 54, 78, 77, 53, 74, 28, 19, 20,
	21, 22, 23, 24, 25, 13, 14, 15, 16, 63,
	17, 62, 59, 52, 51, 36, 35, 47, 50, 89,
	87, 86, 88, 34, 33, 56, 55, 32, 61, 93,
	92, 91, 90, 70, 66, 65, 64, 67, 46, 45,
	40, 38, 39, 84, 60, 42, 82, 80, 31, 44,
	76, 73, 72, 69, 58, 3, 49, 71, 26, 85,
	83, 81, 79, 75, 68, 57, 43, 30, 41, 29,
	12, 10, 9, 8, 7, 6, 5, 4, 2, 1,
}

var yyPact = [...]int{
	-3, -1000, -3, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -2, 59, 28, 25, 24, 17, 16, 46, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 42, 48,
	61, -1000, 41, 40, -16, -29, 20, -1000, -1000, -1000,
	-5, -2, -16, 69, -1000, 12, 47, 46, 11, 9,
	-1000, 38, 37, -1000, 36, -1000, 46, 67, -1000, -1000,
	35, 66, -1000, -1000, -1000, -1000, -4, -1000, 63, -1000,
	-6, -7, -1000, -1000, -1000, 57, -1000, -1000, -1000, 55,
	-1000, 51, -1000, 26, -1000, -1000, 34, 33, 32, 31,
	-1000, -1000, -1000, -1000,
}

var yyPgo = [...]int{
	0, 99, 98, 75, 97, 96, 95, 94, 93, 92,
	91, 4, 90, 89, 88, 2, 0, 87, 86, 85,
	84, 83, 82, 81, 80, 79, 77, 76,
}

var yyR1 = [...]int{
	0, 1, 2, 2, 3, 3, 3, 3, 3, 3,
	3, 10, 27, 27, 27, 9, 8, 26, 26, 26,
	6, 7, 4, 5, 12, 15, 15, 15, 15, 15,
	15, 15, 16, 16, 16, 14, 14, 13, 17, 17,
	18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	23, 23, 24, 24, 25, 25, 25, 25, 25, 11,
	11,
}

var yyR2 = [...]int{
	0, 1, 1, 2, 1, 1, 1, 1, 1, 1,
	1, 4, 1, 2, 2, 4, 6, 0, 1, 1,
	4, 6, 2, 4, 2, 1, 1, 1, 1, 1,
	1, 1, 0, 1, 1, 0, 3, 9, 0, 1,
	0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
	0, 1, 0, 1, 0, 2, 2, 2, 2, 3,
	5,
}

var yyChk = [...]int{
	-1000, -1, -2, -3, -4, -5, -6, -7, -8, -9,
	-10, 4, -12, 28, 29, 30, 31, 33, -15, 21,
	22, 23, 24, 25, 26, 27, -3, -11, 19, -13,
	-17, 9, 19, 19, 19, 19, 19, -16, 15, 16,
	18, -14, 17, -18, 8, 18, 18, -15, 32, -27,
	18, 14, 13, 20, 17, -11, -15, -19, 5, 20,
	17, -16, 20, 20, 18, 18, 18, -16, -20, 6,
	18, -26, 6, 5, 20, -21, 7, 20, 20, -22,
	10, -23, 11, -24, 12, -25, 15, 14, 16, 13,
	18, 18, 18, 18,
}

var yyDef = [...]int{
	0, -2, 1, 2, 4, 5, 6, 7, 8, 9,
	10, 0, 38, 0, 0, 0, 0, 0, 32, 25,
	26, 27, 28, 29, 30, 31, 3, 22, 0, 35,
	40, 39, 0, 0, 0, 0, 0, 24, 33, 34,
	0, 0, 0, 42, 41, 0, 0, 32, 0, 0,
	12, 0, 0, 59, 0, 23, 32, 44, 43, 20,
	0, 17, 15, 11, 13, 14, 0, 36, 46, 45,
	0, 0, 18, 19, 60, 48, 47, 21, 16, 50,
	49, 52, 51, 54, 53, 37, 0, 0, 0, 0,
	55, 56, 57, 58,
}

var yyTok1 = [...]int{
	1,
}

var yyTok2 = [...]int{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33,
}

var yyTok3 = [...]int{
	0,
}

var yyErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	yyDebug        = 0
	yyErrorVerbose = false
)

type yyLexer interface {
	Lex(lval *yySymType) int
	Error(s string)
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

type yyParserImpl struct {
	lval  yySymType
	stack [yyInitialStackSize]yySymType
	char  int
}

func (p *yyParserImpl) Lookahead() int {
	return p.char
}

func yyNewParser() yyParser {
	return &yyParserImpl{}
}

const yyFlag = -1000

func yyTokname(c int) string {
	if c >= 1 && c-1 < len(yyToknames) {
		if yyToknames[c-1] != "" {
			return yyToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func yyStatname(s int) string {
	if s >= 0 && s < len(yyStatenames) {
		if yyStatenames[s] != "" {
			return yyStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func yyErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !yyErrorVerbose {
		return "syntax error"
	}

	for _, e := range yyErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + yyTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := yyPact[state]
	for tok := TOKSTART; tok-1 < len(yyToknames); tok++ {
		if n := base + tok; n >= 0 && n < yyLast && yyChk[yyAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if yyDef[state] == -2 {
		i := 0
		for yyExca[i] != -1 || yyExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; yyExca[i] >= 0; i += 2 {
			tok := yyExca[i]
			if tok < TOKSTART || yyExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if yyExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += yyTokname(tok)
	}
	return res
}

func yylex1(lex yyLexer, lval *yySymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = yyTok1[0]
		goto out
	}
	if char < len(yyTok1) {
		token = yyTok1[char]
		goto out
	}
	if char >= yyPrivate {
		if char < yyPrivate+len(yyTok2) {
			token = yyTok2[char-yyPrivate]
			goto out
		}
	}
	for i := 0; i < len(yyTok3); i += 2 {
		token = yyTok3[i+0]
		if token == char {
			token = yyTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = yyTok2[1] /* unknown char */
	}
	if yyDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(token), uint(char))
	}
	return char, token
}

func yyParse(yylex yyLexer) int {
	return yyNewParser().Parse(yylex)
}

func (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int {
	var yyn int
	var yyVAL yySymType
	var yyDollar []yySymType
	_ = yyDollar // silence set and not used
	yyS := yyrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	yystate := 0
	yyrcvr.char = -1
	yytoken := -1 // yyrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		yystate = -1
		yyrcvr.char = -1
		yytoken = -1
	}()
	yyp := -1
	goto yystack

ret0:
	return 0

ret1:
	return 1

yystack:
	/* put a state and value onto the stack */
	if yyDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", yyTokname(yytoken), yyStatname(yystate))
	}

	yyp++
	if yyp >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyS[yyp] = yyVAL
	yyS[yyp].yys = yystate

yynewstate:
	yyn = yyPact[yystate]
	if yyn <= yyFlag {
		goto yydefault /* simple state */
	}
	if yyrcvr.char < 0 {
		yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
	}
	yyn += yytoken
	if yyn < 0 || yyn >= yyLast {
		goto yydefault
	}
	yyn = yyAct[yyn]
	if yyChk[yyn] == yytoken { /* valid shift */
		yyrcvr.char = -1
		yytoken = -1
		yyVAL = yyrcvr.lval
		yystate = yyn
		if Errflag > 0 {
			Errflag--
		}
		goto yystack
	}

yydefault:
	/* default state action */
	yyn = yyDef[yystate]
	if yyn == -2 {
		if yyrcvr.char < 0 {
			yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if yyExca[xi+0] == -1 && yyExca[xi+1] == yystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			yyn = yyExca[xi+0]
			if yyn < 0 || yyn == yytoken {
				break
			}
		}
		yyn = yyExca[xi+1]
		if yyn < 0 {
			goto ret0
		}
	}
	if yyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			yylex.Error(yyErrorMessage(yystate, yytoken))
			Nerrs++
			if yyDebug >= 1 {
				__yyfmt__.Printf("%s", yyStatname(yystate))
				__yyfmt__.Printf(" saw %s\n", yyTokname(yytoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for yyp >= 0 {
				yyn = yyPact[yyS[yyp].yys] + yyErrCode
				if yyn >= 0 && yyn < yyLast {
					yystate = yyAct[yyn] /* simulate a shift of "error" */
					if yyChk[yystate] == yyErrCode {
						goto yystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if yyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
				}
				yyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yytoken))
			}
			if yytoken == yyEofCode {
				goto ret1
			}
			yyrcvr.char = -1
			yytoken = -1
			goto yynewstate /* try again in the same state */
		}
	}

	/* reduction by production yyn */
	if yyDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
	}

	yynt := yyn
	yypt := yyp
	_ = yypt // guard against "declared and not used"

	yyp -= yyR2[yyn]
	// yyp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if yyp+1 >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyVAL = yyS[yyp+1]

	/* consult goto table to find next state */
	yyn = yyR1[yyn]
	yyg := yyPgo[yyn]
	yyj := yyg + yyS[yyp].yys + 1

	if yyj >= yyLast {
		yystate = yyAct[yyg]
	} else {
		yystate = yyAct[yyj]
		if yyChk[yystate] != -yyn {
			yystate = yyAct[yyg]
		}
	}
	// dummy call; replaced with literal code
	switch yynt {

	case 1:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:91
		{
			x := &ast.Score{NodeList: yyDollar[1].nodeList}
			yylex.(Lexer).SetResult(x)
			yyVAL.score = x
		}
	case 2:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:98
		{
			yyVAL.nodeList = []ast.Node{yyDollar[1].node}
		}
	case 3:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:101
		{
			yyVAL.nodeList = append(yyDollar[1].nodeList, yyDollar[2].node)
		}
	case 11:
		yyDollar = yyS[yypt-4 : yypt+1]
//line cc/crd.y:109
		{
			yyVAL.node = &ast.Transposition{Semitone: yyDollar[3].transpositionDiff}
		}
	case 12:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:114
		{
			yyVAL.transpositionDiff = note.Semitone(yylex.(Lexer).ParseInt(yyDollar[1].token.Value()))
		}
	case 13:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:117
		{
			yyVAL.transpositionDiff = note.Semitone(yylex.(Lexer).ParseInt(yyDollar[2].token.Value()))
		}
	case 14:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:120
		{
			yyVAL.transpositionDiff = note.Semitone(-yylex.(Lexer).ParseInt(yyDollar[2].token.Value()))
		}
	case 15:
		yyDollar = yyS[yypt-4 : yypt+1]
//line cc/crd.y:125
		{
			yyVAL.node = &ast.Instrument{
				Name: yyDollar[3].token.Value(),
			}
		}
	case 16:
		yyDollar = yyS[yypt-6 : yypt+1]
//line cc/crd.y:132
		{
			yyVAL.node = &ast.Key{
				Key: note.NewKey(yyDollar[3].name, yyDollar[4].accidental, yyDollar[5].keyMinor),
			}
		}
	case 17:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:139
		{
			yyVAL.keyMinor = false
		}
	case 18:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:140
		{
			yyVAL.keyMinor = false
		}
	case 19:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:141
		{
			yyVAL.keyMinor = true
		}
	case 20:
		yyDollar = yyS[yypt-4 : yypt+1]
//line cc/crd.y:144
		{
			bpm := yylex.(Lexer).ParseInt(yyDollar[3].token.Value())
			yyVAL.node = &ast.Tempo{
				BPM: bpm,
			}
		}
	case 21:
		yyDollar = yyS[yypt-6 : yypt+1]
//line cc/crd.y:152
		{
			l := yylex.(Lexer)
			n := l.ParseUint8(yyDollar[3].token.Value())
			d := l.ParseUint8(yyDollar[5].token.Value())
			yyVAL.node = &ast.Meter{
				Num:   n,
				Denom: d,
			}
		}
	case 22:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:163
		{
			yyVAL.node = &ast.Rest{Value: yyDollar[2].value}
		}
	case 23:
		yyDollar = yyS[yypt-4 : yypt+1]
//line cc/crd.y:168
		{
			yyVAL.node = &ast.Chord{
				ChordNote:   yyDollar[1].chordNote,
				ChordOption: yyDollar[2].chordOption,
				ChordBase:   yyDollar[3].chordBase,
				Value:       yyDollar[4].value,
			}
		}
	case 24:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:178
		{
			n := note.NewSPN(note.NewNote(yyDollar[1].name, yyDollar[2].accidental), note.Octave(4))
			yyVAL.chordNote = &ast.ChordNote{SPN: n}
		}
	case 25:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:184
		{
			yyVAL.name = note.C
		}
	case 26:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:185
		{
			yyVAL.name = note.D
		}
	case 27:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:186
		{
			yyVAL.name = note.E
		}
	case 28:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:187
		{
			yyVAL.name = note.F
		}
	case 29:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:188
		{
			yyVAL.name = note.G
		}
	case 30:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:189
		{
			yyVAL.name = note.A
		}
	case 31:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:190
		{
			yyVAL.name = note.B
		}
	case 32:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:193
		{
			yyVAL.accidental = note.Natural
		}
	case 33:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:194
		{
			yyVAL.accidental = note.Sharp
		}
	case 34:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:195
		{
			yyVAL.accidental = note.Flat
		}
	case 35:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:198
		{
			yyVAL.chordBase = nil
		}
	case 36:
		yyDollar = yyS[yypt-3 : yypt+1]
//line cc/crd.y:199
		{
			yyVAL.chordBase = &ast.ChordBase{
				Note: note.NewNote(yyDollar[2].name, yyDollar[3].accidental),
			}
		}
	case 37:
		yyDollar = yyS[yypt-9 : yypt+1]
//line cc/crd.y:214
		{
			yyVAL.chordOption = &ast.ChordOption{
				IsAugmented:  yyDollar[1].augmented,
				IsDiminished: yyDollar[2].diminished,
				IsMinor:      yyDollar[3].minor,
				IsMajor:      yyDollar[4].major,
				IsSeventh:    yyDollar[5].seventh,
				IsSixth:      yyDollar[6].sixth,
				IsSuspended:  yyDollar[7].suspended,
				IsForth:      yyDollar[8].forth,
				Accidentaled: yyDollar[9].accidentaled,
			}
		}
	case 38:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:229
		{
			yyVAL.augmented = false
		}
	case 39:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:230
		{
			yyVAL.augmented = true
		}
	case 40:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:233
		{
			yyVAL.diminished = false
		}
	case 41:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:234
		{
			yyVAL.diminished = true
		}
	case 42:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:237
		{
			yyVAL.minor = false
		}
	case 43:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:238
		{
			yyVAL.minor = true
		}
	case 44:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:241
		{
			yyVAL.major = false
		}
	case 45:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:242
		{
			yyVAL.major = true
		}
	case 46:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:245
		{
			yyVAL.seventh = false
		}
	case 47:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:246
		{
			yyVAL.seventh = true
		}
	case 48:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:249
		{
			yyVAL.sixth = false
		}
	case 49:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:250
		{
			yyVAL.sixth = true
		}
	case 50:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:253
		{
			yyVAL.suspended = false
		}
	case 51:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:254
		{
			yyVAL.suspended = true
		}
	case 52:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:257
		{
			yyVAL.forth = false
		}
	case 53:
		yyDollar = yyS[yypt-1 : yypt+1]
//line cc/crd.y:258
		{
			yyVAL.forth = true
		}
	case 54:
		yyDollar = yyS[yypt-0 : yypt+1]
//line cc/crd.y:261
		{
			yyVAL.accidentaled = 0
		}
	case 55:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:262
		{
			yyVAL.accidentaled = yylex.(Lexer).ParseInt(yyDollar[2].token.Value())
		}
	case 56:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:265
		{
			yyVAL.accidentaled = yylex.(Lexer).ParseInt(yyDollar[2].token.Value())
		}
	case 57:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:268
		{
			yyVAL.accidentaled = -yylex.(Lexer).ParseInt(yyDollar[2].token.Value())
		}
	case 58:
		yyDollar = yyS[yypt-2 : yypt+1]
//line cc/crd.y:271
		{
			yyVAL.accidentaled = -yylex.(Lexer).ParseInt(yyDollar[2].token.Value())
		}
	case 59:
		yyDollar = yyS[yypt-3 : yypt+1]
//line cc/crd.y:276
		{
			i := yylex.(Lexer).ParseInt(yyDollar[2].token.Value())
			yyVAL.value = note.NewValue(new(big.Rat).SetInt64(int64(i)))
		}
	case 60:
		yyDollar = yyS[yypt-5 : yypt+1]
//line cc/crd.y:280
		{
			l := yylex.(Lexer)
			x := l.ParseInt(yyDollar[2].token.Value())
			y := l.ParseInt(yyDollar[4].token.Value())
			yyVAL.value = note.NewValue(big.NewRat(int64(x), int64(y)))
		}
	}
	goto yystack /* stack new state and value */
}
